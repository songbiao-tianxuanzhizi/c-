#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
//逻辑与(&&) 
//逻辑与又称做短路与，格式为表达式1&&表达式2&&...
//逻辑与中当所有表达式为真时才为真，当其中有一个为假，则此表达式后面的表达式便不再执行了，当表达式为真时才能继续往后执行
int main(){
	//例子1
	int a = 1;
	int b = 2;
	if (a == 9 && b == 20)//此时表达式a==9不符合条件，所以表达式b==20便不会再执行了，则最后的输出结果为"输入有误".
	{
		printf("%s\n","hellloworld");
	}
	else{
		printf("%s\n","输入有误");
	}

	//例子2
	int c = 1;
	int d = 0;
	int e = 2;
	if (c++&&d++&&e++)
    {
		printf("一：%d%d%d\n", c, d, e);
	}
	else{
		printf("二：%d%d%d\n",c,d,e);/*分析：在这里我们可以看到首先是一个c++语句，由于c++语句是先看c是几然后
									     再递增，那么此时c的值为1（非0），为真（c语言中0为假，非0为真），那么此时
										 执行d++语句，由于执行d++语句时c++语句已经执行完毕，那么此时c的值为2，
										 由于d的值为0，为假，那么此时便不再执行e++语句，那么e的值为2，虽然d++语句虽然为假，
										 但是它只代表其后面的语句不再执行，但其本身仍要执行，所以d的值为1，此时执行的是else
										 里面的语句，执行结果为二：212*/
	}

	//例子3
	int f = 1;
	int g = 0;
	int h = 2;
	if (++f&&++g&&h++)
	{
		printf("一：%d%d%d\n", f, g, h);/*分析：在这里我们可以看到首先是一个++f语句，由于++f语句是先递增
									     那么此时f的值为2非0，为真（c语言中0为假，非0为真），那么此时
										 执行++g语句，与上面d++的情况不同的是，由于++g是递增加1，所以此时g的值为1（非0）
										 所以++g为真，则执行h++语句，由于执行h++语句时++g已经执行完毕
										 那么g的值为1，h++此时先看h是几再递增，此时h为2（非0）为真，则h递增加1后的值为3
										 由于此时if内整个表达式为真，则执行printf("一：%d%d%d\n", f, g, h);，结果为一：213*/
		                                
	}
	else{
		printf("二：%d%d%d\n", f, g, h);
	}

	//例子4
	int i = 0;
	int j = 1;
	int k = 2;
	if (i++&&j++&&k++)
	{
		printf("一：%d%d%d\n", i, j, k);
	}
	else{
		printf("二：%d%d%d\n", i, j, k);/*分析：在这里我们可以看到首先是一个i++语句，由于i++语句是先看i是几然后
									  再递增，那么此时c的值为0，为假（c语言中0为假，非0为真），那么此时表达式
									  j++以及表达式k++都不会再被执行，则j和k的值为1，2；虽然i++为假，但是仍要
									  执行i++语句，则i的值为1，此时执行printf("二：%d%d%d\n", i, j, k);
									  最终的执行结果为二：112*/
	}


	return 0;
}